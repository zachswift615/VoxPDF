# VoxPDF v0.1.0 Implementation Design

**Date**: November 7, 2025
**Version**: v0.1.0 (MVP - Better than PDFKit alone)
**Status**: Design Complete, Ready for Implementation
**Implementation Strategy**: Vertical slices with sub-agent execution

---

## Executive Summary

VoxPDF v0.1.0 will deliver a cross-platform PDF text extraction library optimized for text-to-speech, built with a Rust core and platform-specific bindings. This design document outlines the architecture, implementation plan, and risk mitigation strategies for the first release.

**Key Design Decisions**:
- **Rust core** with `lopdf` (pure Rust PDF parsing)
- **C FFI boundary** with opaque pointers and iterator pattern
- **Swift bindings** for iOS (Listen2 integration)
- **Vertical slice implementation** (feature-by-feature, end-to-end)
- **Validation spike** to de-risk word position extraction

**Success Criteria**:
- Extract text from standard PDFs correctly
- Handle hyphenation across line breaks
- Word-level position tracking for synchronized highlighting
- Intelligent paragraph detection
- TOC extraction from PDF metadata
- Full Swift binding that works end-to-end

---

## Table of Contents

1. [Architecture Overview](#architecture-overview)
2. [Rust Core Design](#rust-core-design)
3. [FFI Boundary Design](#ffi-boundary-design)
4. [Swift Bindings](#swift-bindings)
5. [Implementation Plan](#implementation-plan)
6. [Risk Mitigation](#risk-mitigation)
7. [Testing Strategy](#testing-strategy)
8. [Decision Points](#decision-points)

---

## Architecture Overview

### Three-Layer Architecture

```
┌─────────────────────────────────────┐
│   Swift Layer (iOS App - Listen2)   │
│   - PDFDocument class               │  ← Idiomatic Swift API
│   - Word, Paragraph, Chapter types  │     Auto memory management
│   - Error handling                  │     async/await support
├─────────────────────────────────────┤
│         FFI Boundary (C ABI)        │
│   - Opaque pointers (CVoxPDFDocument)│  ← Stable interface
│   - C structs (CWordPosition)       │     Performance critical
│   - Error codes                     │     Clear ownership
├─────────────────────────────────────┤
│      Rust Core (voxpdf-core)        │
│   - PDF parsing (lopdf)             │  ← All business logic
│   - Text extraction                 │     Memory safe
│   - Layout analysis                 │     Cross-platform
│   - Structure detection             │     Zero Swift dependencies
└─────────────────────────────────────┘
```

### Core Principles

1. **Rust owns all memory** - Swift only holds opaque pointers, never allocates Rust types
2. **FFI is stable** - Can change Rust internals without breaking Swift ABI
3. **Pure Rust core** - No platform-specific code in `voxpdf-core`, enables Android/WASM later
4. **Vertical slices** - Build each feature end-to-end (Rust → FFI → Swift → Test) before moving to next
5. **Validation-first** - Spike risky unknowns early with clear pivot options

### Why This Architecture?

- **Cross-platform foundation**: Matches commercial SDKs (Foxit, PSPDFKit) - Rust core can support iOS, Android, WASM
- **Performance**: C-level speed for PDF processing, zero-copy across FFI where possible
- **Safety**: Memory safety from Rust, no segfaults or undefined behavior
- **Industry standard**: FFI pattern is proven and stable

---

## Rust Core Design

### Module Structure

```
voxpdf-core/src/
├── lib.rs              // Public Rust API + re-exports
├── ffi.rs              // C FFI exports (opaque pointers, error codes)
│
├── pdf/
│   ├── mod.rs          // PDF document loading & access
│   ├── page.rs         // Page-level operations
│   └── metadata.rs     // Document properties, outline
│
├── extraction/
│   ├── mod.rs          // Core text extraction
│   ├── text.rs         // Raw text from lopdf
│   ├── words.rs        // Word boundaries & positions
│   ├── paragraphs.rs   // Paragraph detection
│   └── hyphenation.rs  // Hyphenated word reassembly
│
├── models/
│   ├── mod.rs
│   ├── document.rs     // DocumentContent, Metadata
│   ├── paragraph.rs    // Paragraph struct
│   ├── word.rs         // Word struct with bounds
│   └── chapter.rs      // Chapter/TOC structs
│
└── error.rs            // VoxPDFError enum
```

### Core Data Structures

```rust
// models/document.rs
pub struct DocumentContent {
    pub paragraphs: Vec<Paragraph>,
    pub chapters: Vec<Chapter>,
    pub metadata: Metadata,
}

pub struct Metadata {
    pub title: Option<String>,
    pub author: Option<String>,
    pub page_count: usize,
}

// models/paragraph.rs
pub struct Paragraph {
    pub index: usize,        // Stable position in document
    pub text: String,
    pub page_number: u32,
    pub words: Vec<Word>,
}

// models/word.rs
pub struct Word {
    pub text: String,
    pub bounds: Rect,        // x, y, width, height
    pub page_number: u32,
}

pub struct Rect {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
}

// models/chapter.rs
pub struct Chapter {
    pub title: String,
    pub level: u8,           // 0=chapter, 1=section, etc.
    pub page_number: u32,
    pub paragraph_index: usize,
}
```

### Dependencies

```toml
[dependencies]
lopdf = "0.32"                         # Pure Rust PDF parsing
unicode-segmentation = "1.11"          # Word/grapheme boundaries
thiserror = "1.0"                      # Error handling
once_cell = "1.19"                     # Lazy statics
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
```

### Error Handling

```rust
// error.rs
#[derive(Debug, thiserror::Error)]
pub enum VoxPDFError {
    #[error("Failed to open PDF: {0}")]
    InvalidPDF(String),

    #[error("Page {0} not found (document has {1} pages)")]
    PageNotFound(u32, usize),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("lopdf error: {0}")]
    Lopdf(#[from] lopdf::Error),
}

pub type Result<T> = std::result::Result<T, VoxPDFError>;
```

---

## FFI Boundary Design

### Opaque Pointers Pattern

```rust
// ffi.rs

// Opaque handles (Swift can't see inside)
#[repr(C)]
pub struct CVoxPDFDocument { _private: [u8; 0] }

#[repr(C)]
pub struct CVoxPDFContent { _private: [u8; 0] }

// Simple C structs (copy across boundary)
#[repr(C)]
pub struct CWordPosition {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub page: u32,
}

// Error codes
#[repr(C)]
pub enum CVoxPDFError {
    Ok = 0,
    InvalidPDF = 1,
    PageNotFound = 2,
    IoError = 3,
    OutOfMemory = 4,
}

impl From<VoxPDFError> for CVoxPDFError {
    fn from(err: VoxPDFError) -> Self {
        match err {
            VoxPDFError::InvalidPDF(_) => CVoxPDFError::InvalidPDF,
            VoxPDFError::PageNotFound(..) => CVoxPDFError::PageNotFound,
            VoxPDFError::Io(_) => CVoxPDFError::IoError,
            VoxPDFError::Lopdf(_) => CVoxPDFError::InvalidPDF,
        }
    }
}
```

### Document Lifecycle

```rust
// Open document
#[no_mangle]
pub extern "C" fn voxpdf_open(
    path: *const c_char,
    error_out: *mut CVoxPDFError,
) -> *mut CVoxPDFDocument {
    let path = unsafe { CStr::from_ptr(path) }.to_str().unwrap();

    match PDFDocument::open(path) {
        Ok(doc) => {
            unsafe { *error_out = CVoxPDFError::Ok; }
            Box::into_raw(Box::new(doc)) as *mut CVoxPDFDocument
        }
        Err(e) => {
            unsafe { *error_out = e.into(); }
            std::ptr::null_mut()
        }
    }
}

// Free document
#[no_mangle]
pub extern "C" fn voxpdf_free_document(doc: *mut CVoxPDFDocument) {
    if !doc.is_null() {
        unsafe {
            Box::from_raw(doc as *mut PDFDocument);
        }
    }
}
```

### Content Lifecycle

```rust
// Extract content
#[no_mangle]
pub extern "C" fn voxpdf_extract(
    doc: *const CVoxPDFDocument,
    error_out: *mut CVoxPDFError,
) -> *mut CVoxPDFContent {
    let doc = unsafe { &*(doc as *const PDFDocument) };

    match doc.extract() {
        Ok(content) => {
            unsafe { *error_out = CVoxPDFError::Ok; }
            Box::into_raw(Box::new(content)) as *mut CVoxPDFContent
        }
        Err(e) => {
            unsafe { *error_out = e.into(); }
            std::ptr::null_mut()
        }
    }
}

// Free content
#[no_mangle]
pub extern "C" fn voxpdf_free_content(content: *mut CVoxPDFContent) {
    if !content.is_null() {
        unsafe {
            Box::from_raw(content as *mut DocumentContent);
        }
    }
}
```

### Iterator Pattern for Data Access

**Why iterator pattern?**
- Avoids large copies across FFI boundary
- Efficient for large PDFs (1000+ paragraphs)
- Swift can lazily load data
- Standard pattern in C APIs (SQLite, etc.)

```rust
// Get paragraph count
#[no_mangle]
pub extern "C" fn voxpdf_content_get_paragraph_count(
    content: *const CVoxPDFContent
) -> usize {
    let content = unsafe { &*(content as *const DocumentContent) };
    content.paragraphs.len()
}

// Get paragraph text (one at a time)
#[no_mangle]
pub extern "C" fn voxpdf_content_get_paragraph_text(
    content: *const CVoxPDFContent,
    index: usize,
    text_out: *mut *const c_char,
) -> bool {
    let content = unsafe { &*(content as *const DocumentContent) };

    match content.paragraphs.get(index) {
        Some(para) => {
            let c_str = CString::new(para.text.clone()).unwrap();
            unsafe { *text_out = c_str.into_raw(); }
            true
        }
        None => false
    }
}

// Free string
#[no_mangle]
pub extern "C" fn voxpdf_free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe { CString::from_raw(s); }
    }
}
```

---

## Swift Bindings

### Package Structure

```
voxpdf-swift/
├── Sources/
│   └── VoxPDF/
│       ├── VoxPDF.swift        // Main API
│       ├── PDFDocument.swift   // Swift document type
│       ├── Models.swift        // Swift data models
│       ├── FFI.swift           // C imports
│       └── Internal/
│           └── FFIBridge.swift // Low-level FFI calls
│
├── Tests/
│   └── VoxPDFTests/
│
└── Package.swift
```

### Swift API

```swift
// PDFDocument.swift
public class PDFDocument {
    private let handle: OpaquePointer

    public init(url: URL) throws {
        var error: CVoxPDFError = .Ok
        guard let handle = voxpdf_open(url.path, &error),
              error == .Ok else {
            throw VoxPDFError(code: error)
        }
        self.handle = handle
    }

    deinit {
        voxpdf_free_document(handle)
    }

    public func extract() async throws -> DocumentContent {
        var error: CVoxPDFError = .Ok
        guard let contentHandle = voxpdf_extract(handle, &error),
              error == .Ok else {
            throw VoxPDFError(code: error)
        }
        return DocumentContent(handle: contentHandle)
    }
}

// DocumentContent.swift
public class DocumentContent {
    private let handle: OpaquePointer

    init(handle: OpaquePointer) {
        self.handle = handle
    }

    deinit {
        voxpdf_free_content(handle)
    }

    public var paragraphCount: Int {
        Int(voxpdf_content_get_paragraph_count(handle))
    }

    public func paragraph(at index: Int) -> Paragraph? {
        var textPtr: UnsafePointer<CChar>?
        guard voxpdf_content_get_paragraph_text(handle, index, &textPtr) else {
            return nil
        }
        defer { voxpdf_free_string(UnsafeMutablePointer(mutating: textPtr)) }

        let text = String(cString: textPtr!)
        return Paragraph(text: text, index: index)
    }
}

// Models.swift
public struct Paragraph {
    public let text: String
    public let index: Int
    public let pageNumber: Int
    public let words: [Word]
}

public struct Word {
    public let text: String
    public let bounds: CGRect
    public let pageNumber: Int

    init(c: CWordPosition) {
        self.text = ""  // Filled separately
        self.bounds = CGRect(
            x: CGFloat(c.x),
            y: CGFloat(c.y),
            width: CGFloat(c.width),
            height: CGFloat(c.height)
        )
        self.pageNumber = Int(c.page)
    }
}

public struct Chapter {
    public let title: String
    public let level: Int
    public let pageNumber: Int
}

// Error handling
public enum VoxPDFError: Error {
    case invalidPDF
    case pageNotFound
    case ioError
    case outOfMemory

    init(code: CVoxPDFError) {
        switch code {
        case .InvalidPDF: self = .invalidPDF
        case .PageNotFound: self = .pageNotFound
        case .IoError: self = .ioError
        case .OutOfMemory: self = .outOfMemory
        default: self = .invalidPDF
        }
    }
}
```

---

## Implementation Plan

### Vertical Slice Strategy

Each slice is implemented **end-to-end** (Rust → FFI → Swift → Tests) before moving to the next. This ensures:
- Working pipeline from day 1
- Early validation of FFI boundary
- Integration issues caught immediately
- Can pivot if needed

### Slice Execution Order

#### **Slice 0: lopdf Capability Validation (CRITICAL)**

**Time-box**: 8 hours maximum
**Goal**: Prove lopdf can extract word positions, or pivot to mupdf-sys

**Test fixture**: `tests/fixtures/simple.pdf` (1 page, "Hello World" at known coordinates)

```rust
#[test]
fn spike_validates_word_positions() {
    let doc = lopdf::Document::load("tests/fixtures/simple.pdf").unwrap();
    let words = extract_word_positions(&doc, 0).unwrap();

    let hello = words.iter().find(|w| w.text == "Hello").unwrap();
    let world = words.iter().find(|w| w.text == "World").unwrap();

    // Validate positions within 10% error
    assert!((hello.bounds.x - 100.0).abs() < 10.0);
    assert!((hello.bounds.y - 200.0).abs() < 10.0);
    assert!((world.bounds.x - 160.0).abs() < 10.0);
}
```

**Decision Matrix**:

| Outcome | Criteria | Action |
|---------|----------|--------|
| ✅ **PASS** | Word positions extracted with <10% error | Continue with lopdf, proceed to Slice 1 |
| ⚠️ **PARTIAL** | Can extract text regions but not word-level bounds | **Pivot to Option B**: Ship v0.1.0 without word positions |
| ❌ **FAIL** | Cannot extract positions OR takes >8 hours | **Pivot to Option A**: Switch to mupdf-sys |

**Deliverables**:
- Rust function: `extract_word_positions(&doc, page) -> Vec<Word>`
- FFI function: `voxpdf_get_word_positions(...)`
- Swift binding: `func wordPositions(page: Int) -> [Word]`
- Test: Validates known PDF positions

---

#### **Slice 1: Basic Text Extraction**

**Goal**: Extract raw text from PDFs, validate Rust → FFI → Swift pipeline

**Rust Core**:
```rust
// pdf/mod.rs
pub struct PDFDocument {
    doc: lopdf::Document,
    path: PathBuf,
}

impl PDFDocument {
    pub fn open(path: impl AsRef<Path>) -> Result<Self> {
        let doc = lopdf::Document::load(path.as_ref())?;
        Ok(Self {
            doc,
            path: path.as_ref().to_path_buf()
        })
    }

    pub fn page_count(&self) -> usize {
        self.doc.get_pages().len()
    }
}

// extraction/text.rs
pub fn extract_page_text(doc: &PDFDocument, page_num: u32) -> Result<String> {
    // Use lopdf to extract raw text from page
    // Return concatenated text
}
```

**FFI Layer**:
```rust
#[no_mangle]
pub extern "C" fn voxpdf_open(...) -> *mut CVoxPDFDocument { /* ... */ }

#[no_mangle]
pub extern "C" fn voxpdf_get_page_count(doc: *const CVoxPDFDocument) -> usize { /* ... */ }

#[no_mangle]
pub extern "C" fn voxpdf_extract_page_text(
    doc: *const CVoxPDFDocument,
    page: u32,
    text_out: *mut *const c_char,
) -> bool { /* ... */ }
```

**Swift Binding**:
```swift
public class PDFDocument {
    public var pageCount: Int {
        Int(voxpdf_get_page_count(handle))
    }

    public func text(page: Int) throws -> String {
        // Call FFI, convert to Swift string
    }
}
```

**Tests**:
- Rust: `test_open_simple_pdf()`, `test_extract_simple_text()`
- FFI: `test_ffi_document_lifecycle()`
- Swift: `testBasicExtraction()`

**Success Criteria**:
- Can open `simple.pdf`, `multi-page.pdf`
- Extract text matches expected output
- No memory leaks (Instruments validation)
- Extraction time < 100ms/page

---

#### **Slice 2: Word Position Tracking**

**Goal**: Extract precise bounding boxes for each word (enables highlighting)

**Rust Core**:
```rust
// extraction/words.rs
use unicode_segmentation::UnicodeSegmentation;

pub fn extract_word_positions(doc: &PDFDocument, page_num: u32) -> Result<Vec<Word>> {
    // Use lopdf text positioning APIs
    // Extract bounding box for each word
    // Handle unicode word boundaries
}
```

**FFI Layer**:
```rust
#[no_mangle]
pub extern "C" fn voxpdf_get_word_count(
    doc: *const CVoxPDFDocument,
    page: u32,
) -> usize { /* ... */ }

#[no_mangle]
pub extern "C" fn voxpdf_get_word(
    doc: *const CVoxPDFDocument,
    page: u32,
    index: usize,
    word_out: *mut CWordPosition,
) -> bool { /* ... */ }
```

**Tests**:
- Validate word positions in `simple.pdf` (known coordinates)
- Test unicode handling (CJK, emoji, ligatures)
- Performance: Extract 1000 words in <50ms

**Success Criteria**:
- Word positions accurate within ±2px
- Handles all unicode correctly
- Swift can use bounds for CGRect highlighting

---

#### **Slice 3: Paragraph Detection**

**Goal**: Group lines into logical paragraphs for smooth TTS reading

**Algorithm**:
1. Analyze vertical spacing between word bounds (Y-distance)
2. Merge lines with spacing < 1.5x line height
3. Break on large spacing (>2x line height)
4. Break on indentation changes
5. Avoid merging headers with body text (font size check)

**Rust Core**:
```rust
// extraction/paragraphs.rs
pub fn detect_paragraphs(words: Vec<Word>) -> Vec<Paragraph> {
    // Cluster words into lines by Y-position
    // Cluster lines into paragraphs by spacing
    // Generate paragraph indices
}
```

**Tests**:
- Multi-paragraph document: Verify split points
- Indented paragraphs: Detect properly
- Headers: Don't merge with body text

**Success Criteria**:
- 95%+ accuracy on test PDFs (manual review)
- Paragraphs feel natural for TTS reading

---

#### **Slice 4: Hyphenation Handling**

**Goal**: Reassemble words split across line breaks (e.g., "inter-\nrupt" → "interrupt")

**Algorithm**:
1. Scan for lines ending with '-', '‐', or soft hyphen
2. Check if next line starts with lowercase (not a new sentence)
3. Merge: Remove hyphen, join words
4. Preserve intentional hyphens: "self-contained" stays

**Rust Core**:
```rust
// extraction/hyphenation.rs
pub fn reassemble_hyphenated_words(paragraphs: Vec<Paragraph>) -> Vec<Paragraph> {
    // Detect end-of-line hyphens
    // Merge with next line if lowercase follows
}
```

**Tests**:
- `hyphenated.pdf`: Known hyphenated words
- Preserve intentional hyphens: "self-aware", "real-time"
- Edge cases: em-dash, en-dash, Unicode hyphens

**Success Criteria**:
- All test hyphenations resolved correctly
- No false positives (intentional hyphens preserved)

---

#### **Slice 5: TOC Extraction**

**Goal**: Extract table of contents from PDF metadata for chapter navigation

**Rust Core**:
```rust
// pdf/metadata.rs
pub fn extract_toc(doc: &PDFDocument) -> Vec<Chapter> {
    // Read PDF outline (bookmarks)
    // Map to page numbers
    // Build chapter hierarchy from levels
}
```

**FFI Layer**:
```rust
#[no_mangle]
pub extern "C" fn voxpdf_get_chapter_count(
    content: *const CVoxPDFContent
) -> usize { /* ... */ }

#[no_mangle]
pub extern "C" fn voxpdf_get_chapter(
    content: *const CVoxPDFContent,
    index: usize,
    // ... chapter fields
) -> bool { /* ... */ }
```

**Tests**:
- `toc.pdf`: PDF with outline metadata
- Nested chapters: Validate hierarchy
- No TOC: Return empty array gracefully

**Success Criteria**:
- Extract all chapters from test PDFs
- Hierarchy correct (level 0, 1, 2)
- Page numbers accurate

---

## Risk Mitigation

### Critical Risks

#### 1. lopdf Cannot Extract Word Positions

**Risk Level**: HIGH
**Impact**: Blocks Slice 2, core feature for TTS highlighting

**Mitigation**:
- **Slice 0 validation spike** with 8-hour time-box
- Clear decision matrix for pivot options
- **Pivot Option A**: Switch to `mupdf-sys` (MuPDF has built-in word positions)
- **Pivot Option B**: Ship v0.1.0 without word positions, add in v0.2.0

**Decision Point**: After Slice 0 spike completes

---

#### 2. FFI Memory Leaks

**Risk Level**: MEDIUM
**Impact**: Production crashes, memory growth

**Mitigation**:
- Clear ownership rules documented in code
- Every `_create` has matching `_free`
- Swift `deinit` calls FFI cleanup automatically
- **Validation**: Run Instruments leak detection on every slice
- **Tests**: FFI lifecycle tests (allocate/free 10,000 times)

---

#### 3. Performance Below Targets

**Risk Level**: LOW
**Impact**: TTS feels sluggish, poor UX

**Targets**:
- Extraction: <100ms per page
- Memory: <100MB for 500-page PDF

**Mitigation**:
- Profile early (Slice 1 includes performance tests)
- Optimize hot paths if needed
- Fall back to lazy loading if memory is an issue
- If lopdf is too slow, pivot to mupdf-sys

---

### Pivot Decision Tree

```
Slice 0: Can lopdf extract word positions?
├─ YES → Continue with lopdf
├─ PARTIAL (regions only) → Ship v0.1 without word positions
└─ NO → Switch to mupdf-sys

Performance issues?
├─ Profile and optimize hot paths
├─ Consider mupdf-sys (faster but more complex)
└─ Accept for v0.1, optimize in v0.2
```

---

## Testing Strategy

### Per-Slice Testing

Each slice includes **4 types of tests**:

1. **Rust unit tests**: Algorithm correctness
2. **FFI smoke tests**: Boundary works, no crashes
3. **Swift integration tests**: End-to-end with real PDFs
4. **Performance validation**: Meets time/memory targets

### Test Fixtures

```
voxpdf-core/tests/fixtures/
├── simple.pdf          # 1 page, "Hello World", known positions
├── simple.txt          # Expected output
├── multi-page.pdf      # 3 pages, test pagination
├── multi-page.txt      # Expected output
├── hyphenated.pdf      # Words split across lines
├── hyphenated.txt      # Expected output (reassembled)
├── two-column.pdf      # Multi-column (for v0.2+, included for future)
└── toc.pdf             # PDF with outline metadata
```

Each `.pdf` has corresponding `.txt` with expected extraction output.

### Example Tests

**Rust Unit Test**:
```rust
#[test]
fn test_extract_simple_text() {
    let doc = PDFDocument::open("tests/fixtures/simple.pdf").unwrap();
    let text = extract_page_text(&doc, 0).unwrap();
    let expected = include_str!("fixtures/simple.txt");
    assert_eq!(text.trim(), expected.trim());
}
```

**FFI Lifecycle Test**:
```rust
#[test]
fn test_ffi_document_lifecycle() {
    let path = CString::new("tests/fixtures/simple.pdf").unwrap();
    let mut error = CVoxPDFError::Ok;

    let doc = voxpdf_open(path.as_ptr(), &mut error);
    assert!(!doc.is_null());
    assert_eq!(error, CVoxPDFError::Ok);

    voxpdf_free_document(doc);
}
```

**Swift Integration Test**:
```swift
func testBasicExtraction() async throws {
    let url = Bundle.module.url(forResource: "simple", withExtension: "pdf")!
    let doc = try PDFDocument(url: url)
    let content = try await doc.extract()

    XCTAssertGreaterThan(content.paragraphCount, 0)
    let para = content.paragraph(at: 0)
    XCTAssertNotNil(para)
    XCTAssertFalse(para!.text.isEmpty)
}
```

**Performance Test**:
```rust
#[test]
fn test_extraction_performance() {
    let doc = PDFDocument::open("tests/fixtures/multi-page.pdf").unwrap();
    let start = Instant::now();

    for page in 0..doc.page_count() {
        let _ = extract_page_text(&doc, page as u32).unwrap();
    }

    let elapsed = start.elapsed();
    let per_page = elapsed / doc.page_count() as u32;

    assert!(per_page < Duration::from_millis(100),
            "Extraction took {:?} per page, target is <100ms", per_page);
}
```

### Memory Leak Detection

**Swift Tests with Instruments**:
```bash
# Run tests under Instruments Leaks tool
xcodebuild test -scheme VoxPDF -enableAddressSanitizer YES
```

**Rust Tests**:
```bash
# Valgrind on Linux (if available)
cargo test --target x86_64-unknown-linux-gnu
valgrind --leak-check=full ./target/debug/voxpdf_core-*

# Or use cargo-leak
cargo install cargo-leak
cargo leak test
```

---

## Decision Points

### Checkpoint 1: After Slice 0 (lopdf Validation)

**Question**: Can lopdf extract word positions?

**Decision Matrix**:

| Result | Action |
|--------|--------|
| ✅ Word positions work | Continue to Slice 1 |
| ⚠️ Partial (no word positions) | Skip word positions for v0.1.0, add in v0.2.0 |
| ❌ lopdf insufficient | **PIVOT**: Switch to mupdf-sys, update Cargo.toml |

**Who Decides**: Sub-agent implementing Slice 0
**Evidence Required**: Passing `spike_validates_word_positions()` test

---

### Checkpoint 2: After Slice 1 (Basic Extraction)

**Question**: Does the Rust → FFI → Swift pipeline work end-to-end?

**Success Criteria**:
- Can open PDF in Swift
- Extract text successfully
- No memory leaks
- No crashes

**If Failed**: Debug FFI boundary, check memory ownership

---

### Checkpoint 3: After All Slices Complete

**Question**: Does v0.1.0 meet success criteria?

**Success Criteria**:
- ✅ Extract text from 10+ test PDFs correctly
- ✅ Hyphenation works in all test cases
- ✅ Word positions accurate (±2px)
- ✅ Paragraph boundaries sensible (manual review)
- ✅ TOC extracted when present
- ✅ Performance: <100ms per page
- ✅ Memory: <100MB for 500-page PDF
- ✅ Swift integration works in Listen2

**If Failed**: Prioritize blockers, defer nice-to-haves to v0.2.0

---

## Next Steps

After this design is approved:

1. **Phase 5**: Set up git worktree for implementation
2. **Phase 6**: Create detailed implementation plan for sub-agents
3. **Execute**: Sub-agents implement slices sequentially
4. **Review**: Code review after each slice completes

---

## Appendix: Build Configuration

### Rust Build for iOS

```bash
# Install targets
rustup target add aarch64-apple-ios       # iOS devices
rustup target add x86_64-apple-ios        # iOS simulator
rustup target add aarch64-apple-ios-sim   # M1 simulator

# Build
cargo build --release --target aarch64-apple-ios

# Create XCFramework (bundles all architectures)
./scripts/build-xcframework.sh
```

### Swift Package Manager

```swift
// Package.swift
let package = Package(
    name: "VoxPDF",
    platforms: [.iOS(.v15), .macOS(.v12)],
    products: [
        .library(name: "VoxPDF", targets: ["VoxPDF"]),
    ],
    targets: [
        .binaryTarget(
            name: "VoxPDFCore",
            path: "VoxPDFCore.xcframework"  // Pre-built Rust binary
        ),
        .target(
            name: "VoxPDF",
            dependencies: ["VoxPDFCore"]
        ),
        .testTarget(
            name: "VoxPDFTests",
            dependencies: ["VoxPDF"],
            resources: [.copy("TestPDFs")]
        ),
    ]
)
```

---

**Design Status**: ✅ Complete and Ready for Implementation
**Last Updated**: November 7, 2025
**Next Phase**: Worktree setup and implementation planning
